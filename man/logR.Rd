% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/logR.R
\name{logR}
\alias{logR}
\title{Detailed logging of R call}
\usage{
logR(CALL, tag = NA_character_, in_rows = NA_integer_, silent = TRUE,
  mail = getOption("logR.mail"), mail_args = getOption("logR.mail_args"),
  .db = getOption("logR.db"), .conn = getOption("logR.conn"),
  .table = getOption("logR.table"), .log = getOption("logR.log"))
}
\arguments{
\item{CALL}{call to be evaluted with logging.}

\item{tag}{character, custom metadata to be attached to log entry.}

\item{in_rows}{integer input DF/DT nrow, \emph{logR} can only guest \emph{out_rows}.}

\item{silent}{logical, if default \emph{TRUE} it will not raise warning or error but only log/email it.}

\item{mail}{logical if \emph{TRUE} then on warning/error the email will be send. Requires \emph{mail_args} to be provided. Default \code{getOption("logR.mail",FALSE)}.}

\item{mail_args}{list of args which will override the default logR args passed to \code{mailR::send.mail}, should at least contains \emph{to, from, smtp} elements. Default \code{getOption("logR.mail_args",NULL)}.}

\item{.db}{logical, when \emph{FALSE} then function will write log to csv file instead of database. Default to \code{getOption("logR.db",FALSE)}.}

\item{.conn}{character database connection name defined for \link{db} function. Default to \code{options("logR.conn",NULL)}.}

\item{.table}{character scalar, location in database to store logs, default \code{getOptions("logR.table")}.}

\item{.log}{logical escape parameter, set to \emph{FALSE} to suppress logR process and just execute a call, default to \code{getOption("logR.log",TRUE)}.}
}
\value{
Result of evaluated \emph{CALL}.
}
\description{
Complete logging solution. Writes to database the process metadata before evaluation, and updates the status after completion. Evalutes with timing, catch warning/error, email on warning/errors, log processing details: in/out rows, custom metadata, warning/error messages.
}
\details{
You may expect some silent data types conversion when writing to database, exactly the same as you would use DBI, RODBC, RJDBC packages.
}
\note{
Only first warning will be logged to database.
}
\section{Side effects}{

\itemize{
\item for default \emph{.db} \emph{TRUE} and \emph{.conn} character name of defined db connection the entry in table \emph{.table}.
\item for \emph{.db} \emph{FALSE} the entry in \emph{.table} csv file in working directory.
\item in case of warning or error and \emph{mail} set to \emph{TRUE} also the email will be send according to \emph{mail_args}.
}
}

\section{Database setup}{

Function fetch the unique integer id from the sequence behind the view. View must return \emph{logr_id} column and should be named \code{getOption("logR.seq_view","LOGR_ID")}. Due to various supported database interfaces it is recommended to set maximum value of the sequence to \code{.Machine$integer.max} which is \emph{2147483647}.
Log table named \code{getOption("logR.table","LOGR")} must be created.
See \link{logR_schema} function body for full scripts.
}
\examples{
suppressPackageStartupMessages({
  library(data.table)
  library(logR)
})

dt <- data.table(a = rnorm(10), b = sample(1:5,10,TRUE))

f_success <- function(x){
  x[,.(a=mean(a)),.(b)]
}
f_warning <- function(x){
  x[,.(a=log(a*(-1))),.(b)]
}
f_error <- function(x){
  x[,.(a=a+as.character(a)),.(b)]
}
f_double_warning <- function(){
  warning("warning A")
  r <- 5
  warning("warning B")
  r^2
}
f_nested_double_warning <- function(x){
  z <- f_double_warning()
  r <- x[,.(a=mean(a+z)),.(b)]
}
f_warning_nested_double_warning <- function(x){
  z <- f_double_warning()
  r <- x[,.(a=mean(a+z)),.(b)]
  warning("warning C")
  r
}
f_wait <- function(x){
  Sys.sleep(1.021421)
  x
}

if(requireNamespace("RJDBC",quietly=TRUE) & requireNamespace("RH2",quietly=TRUE)){
  library(RH2)
  h2 <- list(drvName = "JDBC", conn = dbConnect(H2(), "jdbc:h2:mem:"))
  opts <- options("dwtools.db.conns"=list(h2=h2),
                  "logR.db" = TRUE,
                  "logR.conn" = "h2")
  logR_schema()
}

logR(f_success(dt))

logR(f_warning(dt),
     tag = "business_process2") # optional tag to log

logR(f_error(dt),
     tag = "business_process3",
     in_rows = nrow(dt)) # optional in_rows to log

logR(f_nested_double_warning(dt),
     tag = "business_process4",
     in_rows = nrow(dt))

logR(f_warning_nested_double_warning(dt),
     tag = "business_process5",
     in_rows = nrow(dt))

if(requireNamespace("microbenchmark",quietly=TRUE)){
  op <- options("logR.nano" = TRUE)
  logR(f_wait(dt))
  options(op)
} else{
  logR(f_wait(dt))
}

## some expected non catched warnings

suppressWarnings({
  # silent=FALSE
  logR(f_warning_nested_double_warning(dt),
       silent = FALSE,
       tag = "business_process5")
  # invalid in_rows
  logR(f_success(dt),
       tag = "business_process1",
       in_rows = NULL)
})

## preview logs

if(requireNamespace("RJDBC",quietly=TRUE) & requireNamespace("RH2",quietly=TRUE)){
  dwtools::db("LOGR","h2")
  options(opts)
} else {
  fread("LOGR.csv")
  file.remove("LOGR.csv")
}
}

