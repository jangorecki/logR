% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/logR.R
\name{logR}
\alias{logR}
\title{Detailed logging of R call}
\usage{
logR(CALL, tag = NA_character_, in_rows = NA_integer_, silent = TRUE,
  mail = getOption("logR.mail"), mail_args = getOption("logR.mail_args"),
  .db = getOption("logR.db"), .conn = getOption("logR.conn"),
  .table = getOption("logR.table"), .log = getOption("logR.log"))
}
\arguments{
\item{CALL}{call to be evaluted with logging.}

\item{tag}{character, custom metadata to be attached to log entry.}

\item{in_rows}{integer input DF/DT nrow, \emph{logR} can only guess \emph{out_rows}.}

\item{silent}{logical, if default \emph{TRUE} it will not raise warning or error but only log/email it.}

\item{mail}{logical if \emph{TRUE} then on warning/error the email will be send. Requires \emph{mail_args} to be provided. Default \code{getOption("logR.mail",FALSE)}.}

\item{mail_args}{list of args which will overwrite the default logR args passed to \code{mailR::send.mail}, should at least contains \emph{to, from, smtp} elements. Default \code{getOption("logR.mail_args",NULL)}.}

\item{.db}{logical, when \emph{FALSE} then function will write log to csv file instead of database. Default to \code{getOption("logR.db",FALSE)}.}

\item{.conn}{character database connection name defined for \link[dwtools]{db} function. Default to \code{options("logR.conn",NULL)}.}

\item{.table}{character scalar, location in database to store logs, default \code{getOptions("logR.table")}.}

\item{.log}{logical escape parameter, set to \emph{FALSE} to suppress logR process and just execute a call, default to \code{getOption("logR.log",TRUE)}.}
}
\value{
Result of evaluated \emph{CALL}.
}
\description{
Complete logging solution. Writes to database the process metadata before evaluation, and updates the status after completion. Evalutes with timing, catch warning/error, email on warning/errors, log processing details: in/out rows, custom metadata, warning/error messages.
}
\note{
You may expect some silent data types conversion when writing to database, exactly the same as you would use DBI, RODBC, RJDBC packages. Only first warning will be logged to database and send on email.
}
\section{Side effects}{

\itemize{
\item for default \emph{.db} \emph{TRUE} and \emph{.conn} character name of defined db connection - the entry in table \emph{.table}.
\item for \emph{.db} \emph{FALSE} - the entry in \emph{.table} csv file in working directory.
\item in case of warnings or error and \emph{mail} set to \emph{TRUE} also the email will be send according to \emph{mail_args}.
}
}

\section{Database setup}{

Logging process requires 3 database objects:
\itemize{
\item \strong{sequence} - required for transactional logging
\item \strong{view} - query sequence, it isolates various SQL \code{.nextval} calls on the database side
\item \strong{table} - place to store logs
}
You can create all three objects automatically using \link{logR_schema} function, it works for \emph{h2, sql server, postgres, oracle} databases. For other databases you can adjust scripts from \code{schema_sql()}.
View must return \emph{logr_id} column and should be named \code{getOption("logR.seq_view","LOGR_ID")}. Default name of log table is \code{getOption("logR.table","LOGR")}.
Due to various supported database interfaces it is recommended to set maximum value of the sequence to \code{.Machine$integer.max} which is \emph{2147483647}.
}

\section{Fatal errors}{

If your R function will manage to kill whole R session you will see that \emph{status} entry in log table will not get updated and it will stay as \emph{NA}.
It might be worth to schedule a watcher task to detect such cases.
}
\examples{
suppressPackageStartupMessages({
  library(data.table)
  library(logR)
})

dt <- data.table(a = rnorm(10), b = sample(1:5,10,TRUE))

f_success <- function(x){
  x[,.(a=mean(a)),.(b)]
}
f_warning <- function(x){
  x[,.(a=log(a*(-1))),.(b)]
}
f_error <- function(x){
  x[,.(a=a+as.character(a)),.(b)]
}
f_double_warning <- function(){
  warning("warning A")
  r <- 5
  warning("warning B")
  r^2
}
f_nested_double_warning <- function(x){
  z <- f_double_warning()
  r <- x[,.(a=mean(a+z)),.(b)]
}
f_warning_nested_double_warning <- function(x){
  z <- f_double_warning()
  r <- x[,.(a=mean(a+z)),.(b)]
  warning("warning C")
  r
}
f_wait <- function(x){
  Sys.sleep(1.021421)
  x
}

if(requireNamespace("RH2",quietly=TRUE)){
  library(RH2)
  h2 <- list(drvName = "JDBC", conn = dbConnect(H2(), "jdbc:h2:mem:"))
  opts <- options("dwtools.db.conns"=list(h2=h2),
                  "logR.db" = TRUE,
                  "logR.conn" = "h2")
  logR_schema(vendor = "h2")
}

logR(f_success(dt))

logR(f_warning(dt),
     tag = "business_process2") # optional tag to log

logR(f_error(dt),
     tag = "business_process3",
     in_rows = nrow(dt)) # optional in_rows to log

logR(f_nested_double_warning(dt),
     tag = "business_process4",
     in_rows = nrow(dt))

logR(f_warning_nested_double_warning(dt),
     tag = "business_process5",
     in_rows = nrow(dt))

op <- options("logR.nano" = FALSE) # force proc.time instead nanotime
logR(f_wait(dt), tag="nanotime force off")
options(op)

## some expected non catched warnings

suppressWarnings({
  # silent=FALSE
  logR(f_warning_nested_double_warning(dt),
       silent = FALSE,
       tag = "business_process5")
  # invalid in_rows
  logR(f_success(dt),
       tag = "business_process1",
       in_rows = NULL)
})

## preview logs

if(requireNamespace("RH2",quietly=TRUE)){
  dwtools::db("LOGR","h2")
  options(opts)
} else {
  fread("LOGR.csv")
  file.remove("LOGR.csv")
}
}
\seealso{
\link{logR_browser}, \link{logR_schema}, \link{schema_sql}
}

