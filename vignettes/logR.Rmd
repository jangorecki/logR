---
title: "How to use logR"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{logR}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  error = FALSE,
  tidy = FALSE,
  cache = FALSE,
  collapse = TRUE)
```

## Setting up database

The logR uses DBI database interface. In the vignette we will use H2 database because it does not require heavy external dependencies. You can also log to csv file instead of database but logging to csv does not support transactional logging.

```{r connection, message=FALSE}
library(logR)
library(RH2)
options("logR.db" = TRUE,
        "logR.conn" = dbConnect(H2(), "jdbc:h2:mem:"))
```

For the first time we need to create database objects which are required for logR processing: **sequence**, **view** and a **table**.  
Function `logR_schema()` will handle creation of those objects for some databases, you can get plain schema scripts from `schema_sql()` function and adjust it to your database. If your database does not support sequences you may need to simulate a sequence behind the view.

```{r schema}
logR_schema(vendor = "h2")
```

## logR usage

First we will define various functions, some will throw warnings or errors.

```{r usage_fun}
f_success <- function(x){
  x[,.(a=mean(a)),.(b)]
}
f_warning <- function(x){
  x[,.(a=log(a*(-1))),.(b)]
}
f_error <- function(x){
  x[,.(a=a+as.character(a)),.(b)]
}
f_double_warning <- function(){
  warning("warning A")
  r <- 5
  warning("warning B")
  r^2
}
f_nested_double_warning <- function(x){
  z <- f_double_warning()
  x[,.(a=mean(a+z)),.(b)]
}
f_warning_nested_double_warning <- function(x){
  z <- f_double_warning()
  r <- x[,.(a=mean(a+z)),.(b)]
  warning("warning C")
  r
}
f_wait <- function(x){
  Sys.sleep(0.0005)
  x
}
```

Now we will execute defined function wrapping them in logR function to log their processing details.

```{r usage_exec}
library(data.table)
dt <- data.table(a = rnorm(4), b = 1:2)

logR(f_success(dt))
logR(f_warning(dt),
     tag = "business_process2") # optional tag to log
logR(f_error(dt),
     tag = "business_process3",
     in_rows = nrow(dt)) # optional in_rows to log
logR(f_nested_double_warning(dt),
     tag = "business_process4",
     in_rows = nrow(dt))
logR(f_warning_nested_double_warning(dt),
     tag = "business_process5",
     in_rows = nrow(dt))

# proc.time vs nanotime
logR(f_wait(dt),
     tag = "nanotime on")
op <- options("logR.nano" = FALSE)
logR(f_wait(dt),
     tag = "nanotime force off")
options(op)

# log but not suppress exception
logR(f_warning_nested_double_warning(dt),
     silent = FALSE,
     tag = "business_process5")
```

Function calls has been logged to database, you can query them on your database.  
You can also get them back to R just by quering from your table in database. There is handy wrapper to query logs `logR_query()`. Additionally there is shiny app to preview logs in web browser launched by `logR_browser()`.

```{r usage_view}
# preview logs in R
dt <- logR_query()
str(dt)
knitr::kable(dt)
# preview logs in browser using shiny app
if(interactive()) logR_browser()
```

## Fatal errors detection

If your R function will manage to kill whole R session you will see that *status* entry in log table will not get updated and it will remain *NA*.  
Good practice is to have a *crontab* email notifier on crontab errors. Additional check worth to setup can be a watcher task.  
An example of watcher task, assuming that none of tasks should takes more than hour:  

```{r watcher, results='hide'}
watcher <- function(){
  dt <- logR_query()[is.na(status) & logr_start < Sys.time()-60*60]
  if(nrow(dt) > 0L) stop(paste("Unknown status detected by watcher, count:",nrow(dt)))
  invisible()
}
logR(watcher())
```

## Further reading

There are some more customization available not mentioned in the vignette:

- mail notification on exceptions
- custom view and table names
- logging to csv

For more information read `logR` manual by typing `?logR` in R console.

```{r disconnect, echo=FALSE, results='hide'}
invisible(dbDisconnect(getOption("logR.conn")))
```
